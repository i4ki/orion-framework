Orion Framework
Tutorial
Autor: Tiago Natel de Moura

<O> Introdução

O Orion Framework é um conjunto de classes e programas que agilizam o 
desenvolvimento de aplicações voltadas para a web. Eu comecei a desenvolver ele
primeiramente para entender o funcionamento de um framework e também, claro,
agilizar o meu desenvolvimento. Como gostei muito do resultado final, resolvi 
disponibilizá-lo gratuitamente.

Talvez vocês notem que o Orion seja muito diferente de outros frameworks, deve
ser mesmo, pois nunca utilizei um framework PHP. Ele foi escrito para agilizar
o MEU desenvolvimento, portanto não sei se agilizará o SEU, cabe a você, se for
de interesse descobrir. Orion utiliza dos recursos mais modernos do PHP 5.3 
(com excessão de namespaces, que no momento do desenvolvimento o pessoal do
core do PHP estavam numa discussão tão fervorosa que achei que não saíria boa 
coisa, e acho que não saiu mesmo ... ?\?), como:

*	Totalmente Orientado a Objetos
*	INCLUDE automático de classes com a SPL
*	Métodos mágicos ( __get, __set, __isset, __call, __callStatic, etc )
*	create_function --> ALELUIA
*	etc.

Padrões de Projeto:
*	Factory
*	Singleton
*	Command
*	Strategy


<1> Desenvolvimento Rápido

Blá, blá, blá, detesto toda essa história de desenvolvimento Ágil. Porque?
Uma idéia empresarial capitalista, que os escravos (programadores) acataram 
como algo divino. Perde-se o estudo, as pesquisas, a criatividade, o 
desenvolvimento de software decente, pensado e ganha-se softwares feitos em 
períodos em torno de 1 ou 2 meses, sem análises de segurança (ou incompletas), 
pouca criatividade (porque usam o mesmo framework, as mesmas classes, os mesmos 
fixtures, etc).

Hoje em dia, qualquer um iniciante na linguagem (digo que ainda está
aprendendo PHP) pode, em algumas horas, aprender um framework destes do mercado
e sair por aí desenvolvendo e dando palestras como: "Framework XXX, crie um
fórum em dois passos.".

###############################################################################
Aula do dia: Desenvolvendo um blog em 2 linha com o framework AlphaBetaGama.

<?php
require('alphabetagama.php');

$blog = AlphaBetaGama::getInstance()
		->createBlog(array('LIKE' => 'wordpress', 'COMMENTS' => true));

###############################################################################
Aí que está o problema, já não é mais a gente que programa e sim a ZEND, a 
Microsoft, a Intel, etc.

Bom talvez eu seja muito cricri e seja adepto do pensamento mais RAW
do hacking, mas eu acho que as pessoas devem pensar as coisas que fazem.

Mas como assim, você não desenvolveu um framework???
Sim, desenvolvi. Eu sei cada detalhe de como o Orion funciona e como expandi-lo.
Eu sei que ele não é um DEUS, eu sei que ele contém erros, eu sei que se eu
não ativar a opção "csrf-secure: true" no config.yml ele estará vulnerável à
um ataque bem perigoso e mesmo que eu ative essa opção ele ainda estará vulne-
rável, primeiro porque ataques deste tipo são dificeis de conter e segundo por-
que ainda não tive tempo pra implantar esse suporte por todo o framework (hihi).
Mas isso são coisas que eu, que desenvolvi, sei. Se você deseja usar esse frame-
work, tenha em mente que você terá que estudá-lo, estudá-lo a fundo e entender 
cada parte. Se precisar de ajuda: tiago_moura@live.com

#-------------------------------------------------------------------------------
Observações:

Iniciei agora a segunda e mais importante parte do desenvolvimento do Orion. Na
verdade, pode-se dizer que é um framework a parte, mas que trabalhará em con-
junto com o Orion. Será um framework para testes de segurança (PENTEST) na 
aplicação web. Por enquanto ele está sendo desenvolvido somente em PHP, mas
conforme for necessário terei que abrir espaço para linguagens de nível mais
baixo, como o C. Está no começo, ainda no momento da recolha de informações
para o ataque.

O que tenho em mente é que, depois que você desenvolver o seu projeto com o
Orion, você possa rodar o SecurityOrion na aplicação, que sofrerá uma grande
quantidade de ataques automatizados, mais uma vez, não quero promover a burri-
ce, portanto esses ataques serão esquematizados e exploitados pelo desenvol-
vedor. O SecurityOrion somente será o framework de segurança.
-------------------------------------------------------------------------------#

<2> Obtendo

Você pode obter o Orion aqui -> http://www.orionframework.com.br/get/
Se você for feliz, ou seja, usuário Linux, é só descompactar o pacote para
dentro do DocumentRoot do seu servidor apache:
Se o seu DocumentRoot for /var/www fica:

$ tar -zxvf orion-framework-2.tar.gz -C /var/www

PRONTO.

<3> Compreendendo

Como já foi dito, o Orion é um conjunto de classes que podem, se forem bem
utilizadas, agilizar no seu desenvolvimento. Mas para isso você deve ao menos
compreender o seu funcionamento básico.
A classe principal chama-se (adivinha) "Orion" e encontra-se dentro do arquivo
Orion.php (O nome das Classes nem sempre são o mesmo nome do Arquivo).

Como na época do desenvolvimento inicial o PHP não dava suporte a namespaces e 
o tal do suporte estava bem controverso, o Orion não implementa namespaces
entre as suas classes mas isso deve ser implantado em breve.
O Orion segue o seguinte eskema para nome de classes e caminhos de arquivos:

Em relação ao diretório de classes Orion/
#######################################################################
###   CLASSE					###		CAMINHO						###
      Orion						###		../Orion.php				###
	  OrionBuilder				###		Builder.php					###
	  OrionBuilder_Cli			###		Builder/Cli.php				###
	  OrionCommand_Info_Rewrite	###		Command/Info/Rewrite.php	###
#######################################################################
Como você pode ver com excessão da classe principal, as outras seguem
o padrão de que o nome da classe é o caminho do arquivo onde ela se encontra
trocando "_" pelo "/" e retirando o prefixo "Orion" do nome da classe.
Se você conhece o método mágico __autoload do PHP, você deve ter entendido, caso
contrário, sugiro dar uma olhada na documentação. Mas como sei que alguns são
meio preguiçosos, ou acham que deve ser dificil, vou dar uma ajuda: No final
deste tutorial há um capítulo APENDICES, de uma olhada no subcapítulo "SPL E 
AUTOLOAD".

Veja o método que implementa o autoload das classes:

Orion-Framework CODE 1:
@class 	Orion
@method	autoload
################################################################################
	public static function autoload( $classname )
	{
		/**
		 * Se a classe já está registrada na SPL, retorna falso.
		 */
		if( 	class_exists( $classname, false ) || 
				interface_exists( $classname, false ) 
			)
			return false;
		
		/**
		 * Se a classe for a classe principal "Orion"
		 * o arquivo é esse mesmo.
		 */
		if( $classname == 'Orion' )
			$file = __FILE__;
		
		/**
		 * Se o nome dessa classe Inicia com Orion, então essa é uma classe
		 * interna do framework Orion e o caminho do arquivo em que ela
		 * se encontra é o nome dela substituindo "_" pelo "/" e removendo
		 * o prefixo "Orion".
		 */
		elseif( preg_match('/^Orion/', $classname) == 1 ) 
		{
			/**
			 * As classes do Orion iniciam com "Orion" seguido do caminho de 
			 * diretórios em que ela se encontra.
			 * Assim a classe OrionKernel_Dump encontra-se dentro do diretório 
			 * Kernel no arquivo Dump.php
			 */
			$arq = ereg_replace("^Orion",'', $classname);
					
			$file = self::getPath() . DIRECTORY_SEPARATOR . implode(DIRECTORY_SEPARATOR,explode('_',$arq)).'.php';
		} else
			/**
			 * Se não for uma classe Orion, deve procurar no seu diretório de 
			 * bibliotecas
			 */
			 $file = 	dirname(__FILE__) . DIRECTORY_SEPARATOR . 
						self::getAttribute(Orion::ATTR_DIR_APPS) . 
						DIRECTORY_SEPARATOR .
						self::getAttribute(Orion::ATTR_PROJECT) . 
						DIRECTORY_SEPARATOR . 
						self::getAttribute(Orion::ATTR_DIR_LIBS) . 
						DIRECTORY_SEPARATOR . 
						implode( DIRECTORY_SEPARATOR, explode(
															'_',
															$classname
															)
								).'.php';
						
		if( file_exists($file) )
			require_once($file);
		
		return true;
	}
################################################################################
Não muito o que comentar, pois o código já está bem comentado. Se o nome da 
classe seguir o padrão de nomes de classes internos do Orion, esse método
deve tratar esse nome para pegar o path do arquivo que se encontra essa classe.
E incluí-la no código. Não se preocupe com o método Orion::getAttribute(), ele
será comentado na sequencia. O método Orion::getPath() retorna o path do 
diretório das classes Orion.

Quando se trabalha com o Orion, deve-se pensar em projetos Orion. Com apenas
um pacote Orion você poderá ter vários projetos diferentes no mesmo servidor.
Cada projeto deste deve ser configurado e isso você pode fazer de inúmeros
modos. Sobre a forma de configuração dos projetos foi algo em que perdi bastante
tempo, pois sempre penso muito na manutenção do código, performance e segurança 
e estes três itens são muito incompatíveis. Parece que praticidade ou mantebili-
dade é inversamente proporcional à segurança e performance. Isso é um problema.

Queria fazer algo em que se eu, por exemplo, inicia-se um projeto com o sistema
de URL default, ou seja, pegando os parametros da URL por GET, e depois
perto do final quisesse mudar para URL amigáveis, por exemplo, eu tivesse que
somente alterar uma linha. Mais ou menos como as abstrações de banco de dados e
as facilidades nas migrações de driver. Mas ao contrário destas abstrações, não
seria apenas uma ou algumas opções configuráveis, mas sim um framework inteiro e
todas as especializações que cada projeto deveria requerer. Isso sem esquecer
das configurações padrões, colocá-las diretamente no código? num arquivo de 
configuração? Uma coisa que me incomoda muito é que toda vez que um usuário 
acessa uma página, todas as configurações devem ser carregadas, e isso é 
drástico pois se essas configurações estão num arquivo de configuração, esse
arquivo terá que ser aberto à todo clique de cada usuário. Apesar de isto causar
um delay ínfimo, pode começar a causar algum impacto num projeto de grande es-
cala. Mas mesmo se não causasse, é performance desperdiçada e não é bom. O
PHP não dá suporte nativo à cache de variáveis (pelo menos até o momento que 
escrevo não), mas há várias extensões PECL que implementam o cache de variáveis.
Não inclui este recurso do Orion, pois não há alternativas prontas já compilado
no PHP, mas quem sabe num futuro tenhamos. Se você achar necessário incluir
um cache de variáveis ou um bom controle da memória do seu servidor de uma 
olhada nas extensões APC e Memcache, elas são extensões PECL e parece que 
cumprem o que prometem.

Voltando ao problema da configuração do Orion. Já que 
